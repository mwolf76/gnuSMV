-- This file is part of the YASMINE distribution
-- (c) 2011-2016 M. Pensallorto < marco DOT pensallorto AT gmail DOT com >
--
-- This example demonstrates how @input variables van be used to
-- enter input data into a planning reachability problem.
--
-- to run it, the @input vars `from` and `to` must be already defined
-- in the environment. @input variables can be defined using the `set`
-- command.
--
-- e. g.
-- >> set from HOME; set to POSITIVE; check-invar ! GOAL; dump-trace
--
-- Another interesting feature of this example is the TRANS definition
-- for state variable `pos`. Fully non-deterministic next choice
-- specification allows for a natural NFA-like syntax.

MODULE main

VAR
        pos : {
            HOME,
            LOAD1, LOAD2, LOAD3, LOAD4,
            FILLING,
            COVER1, COVER2,
            NEGATIVE, POSITIVE
        };

VAR
        edge : {
             IDLE,

             HOME_TO_LOAD1,
             HOME_TO_LOAD2,
             HOME_TO_LOAD3,
             HOME_TO_LOAD4,

             LOAD1_TO_FILLING,
             LOAD2_TO_FILLING,
             LOAD3_TO_FILLING,
             LOAD4_TO_FILLING,

             FILLING_TO_COVER1,
             FILLING_TO_COVER2,

             COVER1_TO_NEGATIVE,
             COVER1_TO_POSITIVE,
             COVER2_TO_NEGATIVE,
             COVER2_TO_POSITIVE,

             NEGATIVE_TO_HOME,
             POSITIVE_TO_HOME
        };

@input
VAR
        from : {
            HOME,
            LOAD1, LOAD2, LOAD3, LOAD4,
            FILLING,
            COVER1, COVER2,
            NEGATIVE, POSITIVE
        };

        to : {
            HOME,
            LOAD1, LOAD2, LOAD3, LOAD4,
            FILLING,
            COVER1, COVER2,
            NEGATIVE, POSITIVE
        };

INIT
        pos = from;

INIT
        edge = IDLE;

@hidden
DEFINE
        GOAL := pos = to;

-- non-deterministic walk definition
TRANS
        next(pos) = case
                        pos = HOME: { LOAD1, LOAD2, LOAD3, LOAD4 };
                        pos = { LOAD1, LOAD2, LOAD2, LOAD3, LOAD4 } : FILLING;
                        pos = FILLING: { COVER1, COVER2 };
                        pos = { COVER1, COVER2 }: { NEGATIVE, POSITIVE };
                        pos = { NEGATIVE, POSITIVE }: HOME;
                        else: pos;
                    end;

-- once current and next position are chosen edge picking is fully deterministic
TRANS
        next(edge) = case
                         pos = HOME && next(pos) = LOAD1: HOME_TO_LOAD1;
                         pos = HOME && next(pos) = LOAD2: HOME_TO_LOAD2;
                         pos = HOME && next(pos) = LOAD3: HOME_TO_LOAD3;
                         pos = HOME && next(pos) = LOAD4: HOME_TO_LOAD4;

                         pos = LOAD1 && next(pos) = FILLING: LOAD1_TO_FILLING;
                         pos = LOAD2 && next(pos) = FILLING: LOAD2_TO_FILLING;
                         pos = LOAD3 && next(pos) = FILLING: LOAD3_TO_FILLING;
                         pos = LOAD4 && next(pos) = FILLING: LOAD4_TO_FILLING;

                         pos = FILLING && next(pos) = COVER1: FILLING_TO_COVER1;
                         pos = FILLING && next(pos) = COVER2: FILLING_TO_COVER2;

                         pos = COVER1 && next(pos) = NEGATIVE: COVER1_TO_NEGATIVE;
                         pos = COVER1 && next(pos) = POSITIVE: COVER1_TO_POSITIVE;

                         pos = COVER2 && next(pos) = NEGATIVE: COVER2_TO_NEGATIVE;
                         pos = COVER2 && next(pos) = POSITIVE: COVER2_TO_POSITIVE;

                         pos = NEGATIVE && next(pos) = HOME: NEGATIVE_TO_HOME;
                         pos = POSITIVE && next(pos) = HOME: POSITIVE_TO_HOME;
                         else: IDLE;
                     end;

