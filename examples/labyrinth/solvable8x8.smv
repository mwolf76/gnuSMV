#word-width 6
MODULE main

VAR
    _space: boolean[64];
    x, y : uint;

DEFINE _ := FALSE;
DEFINE O := TRUE;

-- Define the labyrinth space. 'O's are obstacles, while '_' are free
-- cells. The labyrinth doesn't change overtime.
INVAR
   0 <= x && 0 <= y;
INVAR
  x <= 7 && y <= 7;
INIT
   _space = [_,_,O,O,_,O,O,O,
             O,_,O,O,_,_,_,_,
             O,_,O,_,_,O,O,_,
             O,_,O,_,_,_,O,_,
             _,_,_,O,O,_,O,_,
             _,_,_,_,O,_,O,_,
             _,O,O,_,_,_,O,_,
             _,_,_,_,O,O,O,_];
INVAR
   next(_space) = _space;

-- our guy starts at the top-left corner,
INIT
   x = 0 && y = 0;

-- he can not occupy a cell which holds an obstacle...
DEFINE
  _pos := 8 * y + x;
INVAR
  !  _space [_pos];

-- can move one step at the time on the X axis
INVAR
   x < next(x) -> next(x) - x = 1;
INVAR
   next(x) < x -> x - next(x) = 1;

-- ... or the Y axis,
INVAR
   y < next(y) -> next(y) - y = 1;
INVAR
   next(y) < y -> y - next(y) = 1;

-- ... not both
INVAR
   (next(x) != x) && (next(y)  = y) ||
   (next(x)  = x) && (next(y) != y) ;

-- his goal is the bottom-right corner
DEFINE
  _GOAL := x = 7 && y = 7;

-- to solve the labyrinth issue the command:
-- check_invar ! _GOAL;
