/*
Copyright (C) 2012 Marco Pensallorto < marco AT pensallorto DOT gmail DOT com >

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

 */

/**
 * @file main.cc
 *
 * @brief Program main body
 *
 */

#include <common.hh>
#include <expr.hh>
#include <expr_printer.hh>
#include <model.hh>
#include <analyzer.hh>

#include    <smvLexer.h>
#include    <smvParser.h>

#include <logging.hh>
namespace axter {
  std::string get_log_prefix_format(const char*FileName,
                                    int LineNo, const char*FunctionName,
                                    ext_data levels_format_usage_data) {
    return
      ezlogger_format_policy::get_log_prefix_format(FileName, LineNo,
                                                    FunctionName,
                                                    levels_format_usage_data);
  }

  std::ostream& get_log_stream() {
    return ezlogger_output_policy::get_log_stream();
  }

  verbosity get_verbosity_level_tolerance(){
    return ezlogger_verbosity_level_policy::get_verbosity_level_tolerance();
  }

  void set_verbosity_level_tolerance(verbosity NewValue){
    ezlogger_verbosity_level_policy::set_verbosity_level_tolerance(NewValue);
  }
};


static void
parseFile(pANTLR3_UINT8 fName)
{
  pANTLR3_INPUT_STREAM input;
  pANTLR3_COMMON_TOKEN_STREAM tstream;

  psmvParser psr;
  psmvLexer  lxr;

  logger << "Preparing for parsing..." << endl;

  input = antlr3FileStreamNew(fName, ANTLR3_ENC_8BIT);
  assert(input);

  lxr = smvLexerNew(input); // smvLexerNew is generated by ANTLR
  assert(lxr);

  tstream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));
  assert(tstream);

  psr = smvParserNew(tstream);  // smvParserNew is generated by ANTLR3
  assert(psr);

  psr->smv(psr);
  logger << "done." << endl;

  psr->free(psr);
  tstream->free(tstream);
  lxr->free(lxr);
  input->close(input);
}

// these are needed to force linking of modules
extern void link_expr();
extern void link_model();

ostream& operator<<(ostream& os, const Expr_ptr t)
{ Printer (os) << t; return os; }

int main(int argc, char *argv[])
{
  link_expr();
  const char* fname = argv[1];

  parseFile((pANTLR3_UINT8) fname);
  Printer prn(cout);

  IModel_ptr M = ModelMgr::INSTANCE().get_model();
  Modules mods = M->get_modules();

  Analyzer analyzer(false);

  for (Modules::iterator eye = mods.begin(); eye != mods.end(); eye ++ ) {
    IModule_ptr pm = eye->second;
    {
      Module& m = dynamic_cast <Module&> (*pm);
      //      const Expr_ptr module_name = m.expr();

      prn << "Module name: "<< m.expr() << "\n";
      const Variables& svars = m.get_localVars();

      prn << "Variables: " << "\n";
      for (Variables::const_iterator veye = svars.begin();
           veye != svars.end(); veye ++ ) {

        IVariable* tmp = veye->second;

        if (StateVar* vp = dynamic_cast<StateVar*> (tmp) ){
          const StateVar& v = (*vp);
          prn << v.expr(); cout << endl;
        }
      }
    }
  }

  analyzer.process();

  return 0;
}
